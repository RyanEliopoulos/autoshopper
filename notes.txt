2/20/2021

    Controller now sorts the recipe lists alphabetically.

    Communicator product_search() method now takes the pagination value as a parametero

    Controller now has init parameters to assist with testing

    Controller wraps communicator.product_search and processes the json data to get only what the view wants

    Controller saves recipes to disk and checks for success.

    The view can now build new recipes, querying the kroger API to populate the recipe with the
    API values associated with the ingredients.

    view now saves the default input buffer value and uses it to undo the disabling of the input echo.
    Otherwise the input("") function wasn't working.

2/18/2021

2U  View design ideas: We are limiting the number of options available on screen at any given time to 5.
                       These will use the a, s, d, f, g keys for input, in that order, top to bottom.
                       Use of fewer than that will fill in from the bottom up, starting with g.

                       The instance variable will track a mapping {'[key]': {'coord': <>, 'text': <>}}
                       used for printing to the screen. Then, local scoping whose context determines which options to
                       present will maintain a dictionary mapping the keys to an index value. This is because each
                       menu context will have a list[] of options associated with it. To properly paginate through the
                       options, given the limit of 5 per screen at a time, and still easily map an input key to an
                       option, such a mapping is necessary. Thus we can have "global" state information for each option
                       slot while compartmentalizing the details based on context.

                       This local {<input_key>: <index>} mapping can be provided by an update_option_slot method, called
                       for each menu context initially and again for each pagination. Thoughts below.


# update_option_slots(options: list, left_index: int, right_index: int) -> dict:
# Local scope tracks the index changing based on pagination input from user.
# method will update the instance variable self.options based on self.option_slots, a list of the possible option slots,
# and the options we are iterating through. Local scope will then call self.print_option_slots() to write the updated
# values
#
# Local index variables can inform decision to include pagination info on the guide string i.e. left_index == 0 means
# no left pagination, right_index >= len(options) means no more right pagination option.
#
# perhaps the method also returns a dictionary of possible choices e.g. a menu with only one option will provide
# this dictionary: {'g': <index>}. The local context can then check user input against this dict for validity.



2U
    Planner <-> view communiation: So I'm relearning that Planner provides a dictionary from the get recipes method.
        This is great because the view needs to know if something is selected or not.

    I'm beginning to really understand the value of functions providing a success/fail int upon returning.


    Tracking color for items is turning out to be too much of an afterthought...

2/17/2021
2U  Think this session we'll build a basic UI for selecting recipes already defined.

    Items need product id as well as UPC - upc is for adding to cart and product id is for item info lookup.

    View and Planner interaction:
        Recipes: They will communicate back and forth based on the index value of the recipes as found in
                    planner.recipes.

        grocery_orders: They will communicate using UPC values



    Thoughts on the way I do commits: Probably doesn't always make sense to do commits an a per-file basis as modifications
                                        in one may be meaningless or breaking without the modifications in another.
                                        This complicates rolling back breaking changes. Soooo yes.
II
    ANSI escape codes: http://ascii-table.com/ansi-escape-sequences-vt-100.php
    Good ones in there for clearing the screen

    The colorama module seems to blanket turn on the ANSI escape sequences that otherwise don't work. Cool.

    Writing to the screen buffer with win32console appears to not support ANSI escape sequences, instead interpreting
    strings literally. Will still be needed to move the cursor around but print() will take care of the text.


2/4/2021

II win32console stuff: The console screen buffer size must always equal or exceed the size of the console window.
                        It seems like the screen buffer is the area characters can be written to.

   Disabling echo, RETURN: Setting the console mode for the std output handle to 0 disables key echo and the
                            requirement for a newline to unblock the ReadConsole() call. Will want this for
                            a "less" type emulation.

   '\b' deletes the character in the previous position?

II pywin32 will allow advance CLI manipulations for windows through the win32console library. Will use curses
   when implementing compatibility with unix-like.

2/2/2021

II Unlike as describe below, the search term "yellow onion" is now properly yielding the "Onions - Yellow - Small"
    product. Weird.

2U  Need to decide on a mechanism to translate unit measurements across recipes. For example, one recipe calls for
    .75 (3/4) cup carrots, one calls for 4 carrots, one calls for a pound of carrots. Could be a file with
    a translation entry for every product.

    An even easier approach is to have all recipes items given in terms of a single unit e.g. .15 pounds of carrots or
    .4 onions. This could get weird with canned food as they can come in various sizes. Oh well, guess that's what
    the productId/UPC is for!!


1/31/2021
II  Came across an API response for product search term "yellow onion" that included a generic yellow onion
    lacking pricing and other information. All fields (pickup, delivery, etc.) showed as unavailable.

    Also clear that not all items in the grocery stores are available through the API.  There are certainly more
    than Kroger brand 3lb bags of onions...I can see them using the user interface :(.

    Good news: It was the search term "yellow onion" simply being insufficiently close to the actual product
                name "Onions - Yellow - Small".  With that string the API gives the produce options by the pound :).




1/30/2021

II Cannot remove items from the customer cart with the API. Evaluate availability of each item before ordering??
    Could just allow substitutions for now and disable them upon first receipt of unacceptable sub.

    Will also need to rely upon Selenium to navigate through order placement once the time comes.  Will put that off
    to focus on building out the recipe inventory system.